from numpy import zeros, dot, cross, array, pi, sum, diag
from numpy.linalg import norm



def divideDipole(f2):
    """
    return a trace part and a traceless symmetric part
    """
    trace = 0.333333333 * (f2[0, 0] + f2[1, 1] + f2[2, 2])
    tracePart = diag(array([trace] * 3))
    traceless = f2 - tracePart
    return (tracePart, traceless)


def detraceDipole(f2):
    return divideDipole(f2)[1]


def monopole(force):
    res = zeros(3)
    for f in force:
        res += force[f]
    return res


def dipole(coordinates, forces, origin=(0,0,0)):
    res = zeros((3, 3))
    for c in coordinates:
        for i in [0, 1, 2]:
            for j in [0, 1, 2]:
                a = coordinates[c][i] - origin[i]
                res[j, i] += a * forces[c][j]
    #return flow.detraceDipole(flow.removeDipoleAntisymmetry(res))
    return flow.detraceDipole(res)


def quadrupole(coordinates, forces, origin=(0, 0, 0)):
    res = zeros((3, 3, 3))
    ii = [0, 1, 2]
    for c in coordinates:
        for i in ii:
            for j in ii:
                for k in ii:
                    ai = coordinates[c][i] - origin[i]
                    aj = coordinates[c][j] - origin[j]
                    res[k, i, j] += ai * aj * forces[c][k]
    return 0.5 * res


def octupole(coordinates, forces, origin=(0, 0, 0)):
    res = zeros((3, 3, 3, 3))
    ii = [0, 1, 2]
    for c in coordinates:
        for i in ii:
            for j in ii:
                for k in ii:
                    for l in ii:
                        h = coordinates[c][i] - origin[i]
                        h *= coordinates[c][j] - origin[j]
                        h *= coordinates[c][k] - origin[k]
                        h *= forces[c][l]
                        res[l, i, j, k] += h
    return 0.166666 * res


def hexapole(coordinates, forces, origin=(0, 0, 0)):
    res = zeros((3, 3, 3, 3, 3))
    ii = [0, 1, 2]
    for c in coordinates:
        for i in ii:
            for j in ii:
                for k in ii:
                    for l in ii:
                        for m in ii:
                            h = coordinates[c][i] - origin[i]
                            h *= coordinates[c][j] - origin[j]
                            h *= coordinates[c][k] - origin[k]
                            h *= coordinates[c][l] - origin[l]
                            h *= forces[c][m]
                            res[m, i, j, k, l] += h
    return 0.04166666 * res

def dissipation(velocities, forces):
    res = 0
    for c in velocities:
        res += dot(velocities[c], forces[c])
    return res


def force(forces):
    """
    given the dictionary, which is generated by the function above,
    calculate the total force, acting on the body.
    """
    res = array([0,0,0])
    for f in forces:
        res = res + array(forces[f])
    return res


def torque(origin, positions, forces):
    """
    given the dictionary from the input reader function above,
    calculate the force dipole
    """
    res = array([0,0,0])
    origin = array(origin)
    for k in positions.keys():
        res = res - cross((array(positions[k]) - origin), forces[k])
    return res


def flowfield(positions, forces):
    """
    with the usual dictionaries of this module, calculate the
    flowfield as the sum of stokeslets.
    """
    const = 1 / 8 / pi / 0.7 # be aware of viscosity being 0.7
    def hFunc(x,y,z):
        r = array([x,y,z])
        res = zeros(3)
        for k in positions:
            f = array(forces[k])
            dr = r - array(positions[k])
            ndr = norm(dr)
            res += (dr * (f[0] * dr[0] + f[1] * dr[1] + f[2] * dr[2]) / ndr ** 2 + f) * const / ndr
        return res
    return hFunc
